<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>image filtering</title><meta name=description content="felladog"><meta name=author content="Utsav Darlami"><link rel="shortcut icon" href=/blogs/img/21-512.png><link rel=stylesheet href=/blogs/css/style.css><link rel=stylesheet href=/blogs/css/syntax.css><link rel=stylesheet href=/blogs/css/toc.css><link rel=stylesheet href=/blogs/katex/katex.min.css><script defer src=/blogs/katex/katex.min.js></script>
<script defer src=/blogs/katex/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script></head><body><header></header><main><div class=toc><nav id=TableOfContents><ul><li><a href=#why-filter-a-image>Why filter a image</a></li><li><a href=#linear-filters>Linear filters</a><ul><li><a href=#gaussian-filter-blur>Gaussian Filter/Blur</a></li></ul></li><li><a href=#non-linear-filters>Non linear filters</a><ul><li><a href=#median--dot-dot-dot-dot-documents-org-notes-2021-05-29-04-28-46z-statistics-dot-md--filter><a href=HAHAHUGOSHORTCODE12s3HBHB>median</a> filter</a></li><li><a href=#entropy--dot-dot-dot-dot-documents-org-notes-2021-03-06-03-56-06z-entropy-dot-md--filter><a href=HAHAHUGOSHORTCODE12s5HBHB>entropy</a> filter</a></li><li><a href=#bilateral-filter>Bilateral filter</a></li><li><a href=#non-local-means-filter>Non-local Means filter</a></li><li><a href=#total-variation-filter>Total Variation filter</a></li><li><a href=#bm3d--block-matching-and-3d-filtering>BM3D (Block Matching and 3D filtering)</a></li><li><a href=#anisotropic-diffusion>anisotropic diffusion</a></li></ul></li><li><a href=#unsharp-mask>Unsharp Mask</a></li><li><a href=#edge-filters--dot-dot-dot-dot-documents-org-notes-2021-05-31-03-54-38z-edge-filters-dot-md><a href=HAHAHUGOSHORTCODE12s11HBHB>Edge Filters</a></a></li><li><a href=#ridge-filters>Ridge filters</a></li><li><a href=#low-and-high-pass-filters>Low and High Pass filters</a><ul><li><a href=#low-pass-filters>Low-Pass Filters:</a></li><li><a href=#high-pass-filters>High-Pass Filters:</a></li></ul></li><li><a href=#discrete-fourier-transform>Discrete Fourier Transform</a></li><li><a href=#in-python>In python</a></li></ul></nav><a href=# class=back-to-top>Back to top</a></div><script src=https://utsavdarlami.github.io/blogs/js/libs/jquery/3.3.1/jquery.slim.min.js></script>
<script>(function(){var t,e=$("#TableOfContents");if(e.length>0){t=$(window);function n(){var n,o=t.scrollTop(),i=$(".body h1, .body h2, .body h3, .body h4, .body h5, .body h6"),s="";if(i.each(function(e,t){t=$(t),t.offset().top-10<=o&&(s=t.attr("id"))}),n=e.find("a.current"),n.length==1&&n.eq(0).attr("href")=="#"+s)return!0;n.each(function(e,t){$(t).removeClass("current").siblings("ul").hide()}),e.find('a[href="#'+s+'"]').parentsUntil("#TableOfContents").each(function(e,t){$(t).children("a").addClass("current").siblings("ul").show()})}t.on("scroll",n),$(document).ready(function(){e.find("a").parent("li").find("ul").hide(),n(),document.getElementsByClassName("toc")[0].style.display=""})}})()</script><p align=right><a href=https://utsavdarlami.github.io/blogs/about>Me</a> |
<a href=https://utsavdarlami.github.io/blogs/>blogs</a> |
<a href=https://utsavdarlami.github.io/blogs/notes>notes</a> |
<a href=https://utsavdarlami.github.io/blogs/tags>tags</a> |
<a href=https://utsavdarlami.github.io/blogs/categories>categories</a> |
<a href=https://utsavdarlami.github.io/blogs/index.xml>feed</a>
<a href=https://utsavdarlami.github.io/>home</a> |</p><article><h1>image filtering</h1><div style=float:left><time>Created Date : 2021 May 28</time></div><br><div style=float:left><time>Last Modified : 2022 February 26</time></div><hr><div>tags:
<a href=/tags/convolution>convolution</a>
<a href=/tags/correlation>correlation</a>
<a href=/tags/filters>filters</a>
<a href=/tags/gaussian>gaussian</a>
<a href=/tags/median>median</a>
<a href=/tags/non-local>non-local</a>
<a href=/tags/bilateral>bilateral</a>
<a href=/tags/bm3d>BM3D</a></div><div style=float:left>categories:
<a href=/categories/image-processing>image processing</a></div><div><hr><ul><li>References :<ul><li>Done Reading</li><li>Reading<ul><li><a href=https://vincmazet.github.io/ftip/convolution.html>https://vincmazet.github.io/ftip/convolution.html</a></li><li><a href=https://nptel.ac.in/courses/106/106/106106224/>https://nptel.ac.in/courses/106/106/106106224/</a> [IIT Madras]</li><li><a href=https://www.cs.cornell.edu/courses/cs5670/2020sp/lectures/lec01%5Ffilter.pdf>Cornell CV Lecture on Filter</a></li><li><a href=https://szeliski.org/Book/>https://szeliski.org/Book/</a> [Book Chapter 3]</li><li><a href=https://scikit-image.org/docs/dev/auto%5Fexamples/filters/plot%5Fnonlocal%5Fmeans.html>Non-local means denoising for preserving textures</a></li></ul></li><li>To read:<ul><li><a href=https://www.cs.tut.fi/~foi/papers/ICIP2019%5FYmir.pdf>https://www.cs.tut.fi/~foi/papers/ICIP2019%5FYmir.pdf</a> [BM3D]</li><li><a href=https://stackoverflow.com/questions/40596026/what-does-entropy-mean-in-this-context>https://stackoverflow.com/questions/40596026/what-does-entropy-mean-in-this-context</a></li></ul></li></ul></li><li>Questions :</li></ul><hr><p>Modify image pixels based on some function of a local neighbourhood of each pixel.</p><h2 id=why-filter-a-image>Why filter a image</h2><ul><li>To sharpen,</li><li>smooth,</li><li>intensify or</li><li>enhance a imag</li></ul><h2 id=linear-filters>Linear filters</h2><ul><li><p>Output pixel’s value is determined as a weighted sum of input pixel values within a small neighborhood N,</p><ul><li>\(g(i, j) = \sum_{k,l}{f(i + k, j + l)h(k, l)}\)</li></ul></li><li><p>The entries in the weight kernel or mask h(k, l) are often called the filter coefficients.</p></li><li><p>The above <strong>correlation</strong> operator can be more compactly notated as</p><ul><li>\(g = f \otimes h\)</li></ul></li><li><p>Correlation can be used for <a href=/blogs/404.html>Template Matching</a></p></li><li><p>Variant of above formula is</p><ul><li>\(g(i, j) = \sum_{k,l}{f(i - k, j - l)h(k, l)}\)</li></ul></li><li><p>where the sign of the offsets in f has been reversed, This is called the <strong>convolution</strong> operator,</p><ul><li>\(g = f \ast h\)</li><li>Equivalent to flip the filter in both directions (bottom to top, right to left) and apply cross-correlation</li></ul></li><li><p>h is called the impulse response function.</p></li><li><p>Difference between convolution and correlation operation</p><ul><li>h, convolved with an impulse signal, δ(i, j) <em>(an image that is 0 everywhere except at the origin)</em> reproduces itself, h * δ = h, whereas correlation produces the reflected signal.</li></ul></li></ul><h3 id=gaussian-filter-blur>Gaussian Filter/Blur</h3><ul><li>good for <a href=/blogs/404.html>denoising</a> normally/gaussian distributed noise</li></ul><figure><img src=/blogs/ox-hugo/2021-05-30_13-23-25_screenshot.png alt="Figure 1: from cornell CV lecture" width=600 height=350><figcaption><p>Figure 1: from cornell CV lecture</p></figcaption></figure><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># img should be float so that operation works properly</span>
</span></span><span class=line><span class=cl><span class=n>g_img1</span> <span class=o>=</span> <span class=n>cv2</span><span class=o>.</span><span class=n>GaussianBlur</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=mi>3</span><span class=p>),</span> <span class=mi>0</span><span class=p>,</span> <span class=n>borderType</span><span class=o>=</span><span class=n>cv2</span><span class=o>.</span><span class=n>BORDER_CONSTANT</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>g_img2</span> <span class=o>=</span> <span class=n>skimage</span><span class=o>.</span><span class=n>filters</span><span class=o>.</span><span class=n>gaussian</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=n>sigma</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>mode</span><span class=o>=</span><span class=s1>&#39;constant&#39;</span><span class=p>,</span> <span class=n>cval</span><span class=o>=</span><span class=mf>0.0</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=non-linear-filters>Non linear filters</h2><h3 id=median--dot-dot-dot-dot-documents-org-notes-2021-05-29-04-28-46z-statistics-dot-md--filter><a href=/blogs/404.html>median</a> filter</h3><ul><li>for denoising the salt and pepper noise</li><li>Replace each pixel with MEDIAN value of all pixels in neighbourhood</li><li>median calculation over the given filter size</li><li>Properties:<ul><li>Non-linear</li><li>Does not spread noise</li><li>Can remove spike noise</li><li>Robust to outliers, but not good for Gaussian noise</li></ul></li></ul><figure><img src=/blogs/ox-hugo/2021-05-29_18-01-48_screenshot.png alt="Figure 2: from nptel [IIT Madras] CV lecture slide" width=450 height=250><figcaption><p>Figure 2: from nptel [IIT Madras] CV lecture slide</p></figcaption></figure><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.filters</span> <span class=kn>import</span> <span class=n>median</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.morphology</span> <span class=kn>import</span> <span class=n>disk</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>median_cv</span> <span class=o>=</span> <span class=n>cv2</span><span class=o>.</span><span class=n>medianBlur</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>median_skimage</span> <span class=o>=</span> <span class=n>median</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=n>disk</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span> <span class=n>mode</span><span class=o>=</span><span class=s1>&#39;constant&#39;</span><span class=p>,</span> <span class=n>cval</span><span class=o>=</span><span class=mf>0.0</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=entropy--dot-dot-dot-dot-documents-org-notes-2021-03-06-03-56-06z-entropy-dot-md--filter><a href=/blogs/404.html>entropy</a> filter</h3><p>The entropy filter can detect subtle variations in the local gray level distribution. It is usually used to classify textures, a certain texture might have a certain entropy as certain patterns repeat themselves in approximately certain ways.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.filters.rank</span> <span class=kn>import</span> <span class=n>entropy</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.morphology</span> <span class=kn>import</span> <span class=n>disk</span>
</span></span><span class=line><span class=cl><span class=n>entropy_img</span> <span class=o>=</span> <span class=n>entropy</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=n>disk</span><span class=p>(</span><span class=mi>3</span><span class=p>))</span>
</span></span></code></pre></div><h3 id=bilateral-filter>Bilateral filter</h3><ul><li>Edge perserving denoising filter.</li><li>Noise removal comes at expense of image blurring at edges.</li><li>Simple, non-linear edge-preserving smoothing.</li><li>Reject(in a soft manner) pixels whose values differ too much from the central pixel value(outlier rejection).</li><li>Output pixel value is weighted combination of neighboring pixel values:
\(g(i,j) = \frac{\sum_{k,l}f(k,l) w(i,j,k,l)}{\sum_{k,l}w(i,j,k,l)}\)</li></ul><figure><img src=/blogs/ox-hugo/2021-05-29_17-56-31_screenshot.png alt="Figure 3: from szeliski book, chapter 3" width=600 height=300><figcaption><p>Figure 3: from szeliski book, chapter 3</p></figcaption></figure><ul><li>\(\sigma_{d}\) controls influence of the distant pixels.</li><li>\(\sigma_{r}\) controls the influence of pixels with intensity value different from center pixel intensity.</li></ul><figure><img src=/blogs/ox-hugo/2021-05-29_17-57-56_screenshot.png alt="Figure 4: from szeliski book, chapter 3" width=500 height=350><figcaption><p>Figure 4: from szeliski book, chapter 3</p></figcaption></figure><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>bilateral_img_cv</span> <span class=o>=</span> <span class=n>cv2</span><span class=o>.</span><span class=n>bilateralFilter</span><span class=p>(</span><span class=n>image</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				    <span class=n>d</span><span class=o>=</span><span class=mi>5</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				    <span class=n>sigmaColor</span><span class=o>=</span><span class=mi>20</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				    <span class=n>sigmaSpace</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				    <span class=n>borderType</span><span class=o>=</span><span class=n>cv2</span><span class=o>.</span><span class=n>BORDER_CONSTANT</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.restoration</span> <span class=kn>import</span> <span class=n>denoise_bilateral</span>
</span></span><span class=line><span class=cl><span class=n>bilateral_img_sk</span>  <span class=o>=</span> <span class=n>denoise_bilateral</span><span class=p>(</span><span class=n>image</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				      <span class=n>win_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				      <span class=n>sigma_color</span><span class=o>=</span><span class=mf>0.05</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				      <span class=n>sigma_spatial</span><span class=o>=</span><span class=mi>15</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				      <span class=n>mode</span><span class=o>=</span><span class=s1>&#39;constant&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				      <span class=n>cval</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				      <span class=n>multichannel</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=non-local-means-filter>Non-local Means filter</h3><ul><li>Estimated value is the weighted average of all pixels in the image but, the family of weights depend on the similarity between the pixels i and j.</li><li>Similar pixel neighborhoods give larger weights.</li><li><em>The non-local means algorithm replaces the value of a pixel by an average of a selection of other pixels values: small patches centered on the other pixels are compared to the patch centered on the pixel of interest, and the average is performed only for pixels that have patches close to the current patch. As a result, this algorithm can restore well textures, that would be blurred by other denoising algorithm.</em></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>https://scikit-image.org/docs/dev/auto_examples/filters/plot_nonlocal_means.html
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.restoration</span> <span class=kn>import</span> <span class=n>denoise_nl_means</span><span class=p>,</span> <span class=n>estimate_sigma</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sigma_est</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>estimate_sigma</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=n>multichannel</span><span class=o>=</span><span class=kc>False</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>denoise_img</span> <span class=o>=</span> <span class=n>denoise_nl_means</span><span class=p>(</span><span class=n>img</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			       <span class=n>h</span><span class=o>=</span><span class=mf>1.0</span><span class=o>*</span><span class=n>sigma_est</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			       <span class=n>fast_mode</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			       <span class=n>patch_size</span><span class=o>=</span><span class=mi>5</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			       <span class=n>patch_distance</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			       <span class=n>multichannel</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=total-variation-filter>Total Variation filter</h3><ul><li><p>Signal with excessive spurious(counterfeit) detail have high total variation</p></li><li><p>Reducing the total variation of the signal, removes unwanted detail while preserving important details such as edges.</p></li><li><p>The result of this filter is an image that has a minimal total variation norm, while being as close to the initial image as possible.</p></li><li><p>The total variation is the L1 norm of the gradient of the image.</p></li><li><p>good for normally/gaussian distributed noise</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.restoration</span> <span class=kn>import</span> <span class=n>denoise_tv_chambolle</span>
</span></span><span class=line><span class=cl><span class=n>denoise_img_tv</span> <span class=o>=</span> <span class=n>denoise_tv_chambolle</span><span class=p>(</span><span class=n>img</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				  <span class=n>weight</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				  <span class=n>eps</span><span class=o>=</span><span class=mf>0.0002</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				  <span class=n>n_iter_max</span><span class=o>=</span><span class=mi>200</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				  <span class=n>multichannel</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span></code></pre></div></li></ul><h3 id=bm3d--block-matching-and-3d-filtering>BM3D (Block Matching and 3D filtering)</h3><ul><li>Collaborative filtering process</li><li>Group of similar blocks extracted from the image.</li><li>A block is grouped if its dissimilarity with a reference fragment falls below a specified threshold - block matching.</li><li>All blocks in a group are then stacked together to form 3D cylinder- like shapes.</li><li>Filtering is done on every block group.</li><li>Linear transform is applied followed by wiener filtering, then transform is inverted to reproduce all filtered blocks.</li><li>Image transformed back to its 2D form.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>bm3d</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2> bm3d library is not well documented yet, but looking into source code....
</span></span></span><span class=line><span class=cl><span class=s2> sigma_psd - noise standard deviation
</span></span></span><span class=line><span class=cl><span class=s2> stage_arg: Determines whether to perform hard-thresholding or Wiener filtering.
</span></span></span><span class=line><span class=cl><span class=s2> stage_arg = BM3DStages.HARD_THRESHOLDING or BM3DStages.ALL_STAGES (slow but powerful)
</span></span></span><span class=line><span class=cl><span class=s2> All stages performs both hard thresholding and Wiener filtering.
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=n>bm3d_denoised</span> <span class=o>=</span> <span class=n>dm3d</span><span class=o>.</span><span class=n>bm3d</span><span class=p>(</span><span class=n>noisy_img</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			  <span class=n>sigma_psd</span><span class=o>=</span><span class=mf>0.2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			  <span class=n>stage_arg</span><span class=o>=</span><span class=n>bm3d</span><span class=o>.</span><span class=n>BM3DStages</span><span class=o>.</span><span class=n>ALL_STAGES</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=anisotropic-diffusion>anisotropic diffusion</h3><h2 id=unsharp-mask>Unsharp Mask</h2><ul><li>Sharped = Original Image + (Orginial - Gaussian Blurred Image) * Amount</li></ul><figure><img src=/blogs/ox-hugo/2021-05-30_12-56-17_screenshot.png alt="Figure 5: from cornell CV lecture" width=500 height=400><figcaption><p>Figure 5: from cornell CV lecture</p></figcaption></figure><figure><img src=/blogs/ox-hugo/2021-05-30_13-01-41_screenshot.png alt="Figure 6: from cornell CV lecture" width=650 height=300><figcaption><p>Figure 6: from cornell CV lecture</p></figcaption></figure><figure><img src=/blogs/ox-hugo/2021-05-30_13-13-43_screenshot.png alt="Figure 7: from cornell CV lecture" width=650 height=350><figcaption><p>Figure 7: from cornell CV lecture</p></figcaption></figure><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.filters</span> <span class=kn>import</span> <span class=n>unsharp_mask</span>
</span></span><span class=line><span class=cl><span class=n>unsharped_img</span> <span class=o>=</span> <span class=n>unsharp_mask</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=n>radius</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=n>amount</span><span class=o>=</span><span class=mf>1.0</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=edge-filters--dot-dot-dot-dot-documents-org-notes-2021-05-31-03-54-38z-edge-filters-dot-md><a href=/blogs/404.html>Edge Filters</a></h2><h2 id=ridge-filters>Ridge filters</h2><ul><li><p>for detecting ridges in the image</p></li><li><p>In skimage</p><ul><li>meijering</li><li>sato</li><li>frangi</li><li>hessian</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.filters</span> <span class=kn>import</span> <span class=n>meijering</span><span class=p>,</span> <span class=n>sato</span><span class=p>,</span> <span class=n>frangi</span><span class=p>,</span> <span class=n>hessian</span>
</span></span><span class=line><span class=cl><span class=n>meijering_img</span> <span class=o>=</span> <span class=n>meijering</span><span class=p>(</span><span class=n>img</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>sato_img</span>  <span class=o>=</span> <span class=n>sato</span><span class=p>(</span><span class=n>meijering</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>frangi_img</span><span class=o>=</span> <span class=n>frangi</span><span class=p>(</span><span class=n>img</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>hessian_img</span> <span class=o>=</span> <span class=n>hessian</span><span class=p>(</span><span class=n>img</span><span class=p>)</span>
</span></span></code></pre></div></li></ul><h2 id=low-and-high-pass-filters>Low and High Pass filters</h2><h3 id=low-pass-filters>Low-Pass Filters:</h3><ul><li>Filters that allow low frequencies to pass through (block high frequencies).</li><li>Example: Gaussian filter</li></ul><h3 id=high-pass-filters>High-Pass Filters:</h3><ul><li>Filters that allow high frequencies to pass through (block low frequencies).</li><li>Example: Edge filter</li></ul><h2 id=discrete-fourier-transform>Discrete Fourier Transform</h2><ul><li><a href=/blogs/404.html>dft_in_image</a></li></ul><h2 id=in-python>In python</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>cv2</span>
</span></span><span class=line><span class=cl><span class=c1># img dtype should be checked so that operation works properly</span>
</span></span><span class=line><span class=cl><span class=c1># applying filter using opencv</span>
</span></span><span class=line><span class=cl><span class=n>convolved_image</span> <span class=o>=</span> <span class=n>cv2</span><span class=o>.</span><span class=n>filter2D</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>kernel</span><span class=p>,</span> <span class=n>borderType</span><span class=o>=</span><span class=n>cv2</span><span class=o>.</span><span class=n>BORDER_CONSTANT</span><span class=p>)</span>
</span></span></code></pre></div></div><p style=font-size:1.65em;text-align:center><a href=/blogs/notes/2021-05-26--11-31-31z--neural_network/>&#8678;</a>
<a href=/blogs/notes/2021-05-30--08-53-22z--gradient/>&#8680;</a></p><hr><div class=bl-section><h4>Links to this note</h4><div class=backlinks><ul><li><a href=/blogs/notes/2021-03-06--03-56-06z--entropy/>entropy</a></li></ul></div></div><hr><footer><main><h3>Comments</h3><script src=https://utteranc.es/client.js repo=utsavdarlami/blogs issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></main></footer></article></main><footer></footer></body></html>