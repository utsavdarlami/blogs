<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Building a Dummy Agentic System and My Naive Lens on AI Agents</title>
<meta name=description content="felladog"><meta name=author content="Utsav Darlami"><link rel="shortcut icon" href=/blogs/img/21-512.png><link rel=stylesheet href=/blogs/css/style.css><link rel=stylesheet href=/blogs/css/syntax.css><link rel=stylesheet href=/blogs/css/toc.css><link rel=stylesheet href=/blogs/katex/katex.min.css><script defer src=/blogs/katex/katex.min.js></script><script defer src=/blogs/katex/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script></head><body><header></header><main><div class=toc><nav id=TableOfContents><ul><li><a href=#demo-of-the-system>Demo of the system</a></li><li><a href=#every-app-is-a-state-machine>Every App is a State Machine</a></li><li><a href=#tools-apis-plus-common-sense>Tools = APIs + Common Sense</a></li><li><a href=#how-tool-calling-works>How Tool Calling Works</a></li><li><a href=#the-system-prompt>The System Prompt</a></li><li><a href=#natural-language-interfaces>Natural Language Interfaces</a></li><li><a href=#wrapping-up>Wrapping Up</a></li></ul></nav><a href=# class=back-to-top>Back to top</a></div><script src=https://utsavdarlami.github.io/blogs/js/libs/jquery/3.3.1/jquery.slim.min.js></script><script>(function(){var t,e=$("#TableOfContents");if(e.length>0){t=$(window);function n(){var n,o=t.scrollTop(),i=$(".body h1, .body h2, .body h3, .body h4, .body h5, .body h6"),s="";if(i.each(function(e,t){t=$(t),t.offset().top-10<=o&&(s=t.attr("id"))}),n=e.find("a.current"),n.length==1&&n.eq(0).attr("href")=="#"+s)return!0;n.each(function(e,t){$(t).removeClass("current").siblings("ul").hide()}),e.find('a[href="#'+s+'"]').parentsUntil("#TableOfContents").each(function(e,t){$(t).children("a").addClass("current").siblings("ul").show()})}t.on("scroll",n),$(document).ready(function(){e.find("a").parent("li").find("ul").hide(),n(),document.getElementsByClassName("toc")[0].style.display=""})}})()</script><p align=right><a href=https://utsavdarlami.github.io/blogs/about>me</a> |
<a href=https://utsavdarlami.github.io/blogs/>blogs</a> |
<a href=https://utsavdarlami.github.io/blogs/notes>notes</a> |
<a href=https://utsavdarlami.github.io/blogs/tags>tags</a> |
<a href=https://utsavdarlami.github.io/blogs/categories>categories</a> |
<a href=https://utsavdarlami.github.io/blogs/index.xml>feed</a> |
<a href=https://utsavdarlami.github.io/dlog/>dlog</a> |
<a href=https://utsavdarlami.github.io/>home</a> |</p><article><h1>Building a Dummy Agentic System and My Naive Lens on AI Agents</h1><div style=float:left><time>Created Date : 2026 January 31</time></div><br><div style=float:left><time>Last Modified : 2026 January 31</time></div><hr><div>tags:
<a href=/tags/python>python</a>
<a href=/tags/llm>llm</a>
<a href=/tags/agent>agent</a>
<a href=/tags/google-adk>google-adk</a></div><div style=float:left>categories:
<a href=/categories/python>python</a>
<a href=/categories/agent>agent</a>
<a href=/categories/llm>llm</a></div><div><hr><ul><li>References, Credits and Inspirations:<ul><li><a href=https://danicat.dev/posts/20251031-building-aida/>Beyond the Dev-UI: How to Build an Interface for an ADK agent</a></li><li><a href=https://google.github.io/adk-docs/>Google Agent Development Kit (ADK)</a></li><li><a href=https://amitness.com/posts/function-calling-schema/>The Anatomy of Tool Calling</a> - A deep dive into Python functions and tool calling.</li><li><a href=https://ampcode.com/how-to-build-an-agent>How to Build an Agent</a> - [Agent building from AMP]</li></ul></li><li>Questions :</li></ul><hr><p>Everyone is talking about &ldquo;Agents&rdquo; right now. It feels like we went from &ldquo;AI that writes poems&rdquo; to &ldquo;AI that fixes my code&rdquo; overnight. But if you strip away the hype, what actually <em>is</em> an agent?</p><p>I recently read a great blog <em><a href=https://ampcode.com/how-to-build-an-agent>&ldquo;How to Build an Agent&rdquo;</a></em> and the takeaway was refreshing: <strong>The Emperor has no clothes.</strong> An agent isn&rsquo;t some sentient magic box; it’s an LLM, a loop, and a set of tools.</p><p>This inspired me to build a <strong><a href=https://github.com/utsavdarlami/agent-starter-template>Dummy Agentic System</a></strong> (a dummy system to demonstrate agent capabilities) with the <strong><a href=https://google.github.io/adk-docs/>Google ADK</a></strong>. In doing so, I realized something fundamental about how software is changing.</p><h2 id=demo-of-the-system>Demo of the system</h2><p>It&rsquo;s a simple canvas where users can add, move, or delete 2D shapes (circles, squares, triangles) using a chat interface.</p><p><strong>State 0: Initial State</strong>
We start with a circle and a triangle.</p><figure><img src=https://raw.githubusercontent.com/utsavdarlami/agent-starter-template/refs/heads/main/state_screenshots/state_1.png width=100% height=100%></figure><p><strong>State 1: The Complex Intent</strong>
I asked the agent: <em>&ldquo;add triangle at position where current square is and update the position of square to 20, 20&rdquo;</em>
The agent understood it had to read the current coordinates (get info), create a new object (write), and modify the existing one (update).</p><figure><img src=https://raw.githubusercontent.com/utsavdarlami/agent-starter-template/refs/heads/main/state_screenshots/state_2.png width=100% height=100%></figure><p><strong>State 2: The Semantic Deletion</strong>
Finally, I asked it to <em>&ldquo;remove the circle.&rdquo;</em>
I didn&rsquo;t provide an ID. I didn&rsquo;t click a trash icon. The agent found the ID from the state and called the tool.</p><figure><img src=https://raw.githubusercontent.com/utsavdarlami/agent-starter-template/refs/heads/main/state_screenshots/state_3.png width=100% height=100%></figure><h2 id=every-app-is-a-state-machine>Every App is a State Machine</h2><p>In this system, the &ldquo;State&rdquo; is just a list of objects on the canvas: <code>[{"id": "circle_1", "x": 10, "y": 10}, ...]</code>. The agent&rsquo;s only job is to manipulate this list based on user commands.</p><p>I have started to view modern apps that leverage agents through a naive lens: <strong>They are apps that let an LLM modify their state.</strong> Of course, there goes more thoughts on actually implementing it.</p><ul><li><strong>Coding Agents (Cursor, Windsurf, Amp, ..):</strong> The state is your file system. The LLM modifies text strings.</li><li><strong>Excalidraw&rsquo;s AI:</strong> The state is the canvas elements. The LLM adds/removes shapes.</li><li><strong>Notion AI:</strong> The state is the document block tree. The LLM inserts paragraphs.</li></ul><p>That’s why every app seems to have its own agent now. They expose their internal state to a new kind of operator. Whether you move a &ldquo;Red Square&rdquo; to <code>x:20</code> or refactor a Python function in <code>main.py</code>, it&rsquo;s the same thing: <strong>State Mutation</strong>.</p><p>To update this state, the agent leverages tools defined by the creator.</p><h2 id=tools-apis-plus-common-sense>Tools = APIs + Common Sense</h2><p>Coming from the pre-LLM era, you might look at &ldquo;Agent Tools&rdquo; and think, &ldquo;Isn&rsquo;t this just an API call?&rdquo; And you&rsquo;d be right. But there is a massive difference in <strong>who</strong> constructs the payload.</p><p>Previously, to remove an object, the user (or the frontend client code) needed to know the exact schema: <code>DELETE /api/objects/{object_id}</code>. You couldn&rsquo;t just send &ldquo;remove the circle.&rdquo;</p><p>In my implementation, I exposed a simple interface: <code>tool_delete_object(id)</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@tool_safe</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>tool_delete_object</span><span class=p>(</span><span class=n>tool_context</span><span class=p>:</span> <span class=n>ToolContext</span><span class=p>,</span> <span class=n>object_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Any</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Delete an object from the state by its ID.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        object_id: The ID of the object to delete.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>state</span> <span class=o>=</span> <span class=n>tool_context</span><span class=o>.</span><span class=n>state</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&#34;current_state&#34;</span><span class=p>,</span> <span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=s2>&#34;objects&#34;</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>state</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;error&#34;</span><span class=p>,</span> <span class=s2>&#34;message&#34;</span><span class=p>:</span> <span class=s2>&#34;No objects found in state.&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>original_count</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>state</span><span class=p>[</span><span class=s2>&#34;objects&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>state</span><span class=p>[</span><span class=s2>&#34;objects&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=n>obj</span> <span class=k>for</span> <span class=n>obj</span> <span class=ow>in</span> <span class=n>state</span><span class=p>[</span><span class=s2>&#34;objects&#34;</span><span class=p>]</span> <span class=k>if</span> <span class=n>obj</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&#34;id&#34;</span><span class=p>)</span> <span class=o>!=</span> <span class=n>object_id</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>state</span><span class=p>[</span><span class=s2>&#34;objects&#34;</span><span class=p>])</span> <span class=o>==</span> <span class=n>original_count</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;error&#34;</span><span class=p>,</span> <span class=s2>&#34;message&#34;</span><span class=p>:</span> <span class=sa>f</span><span class=s2>&#34;Object with ID </span><span class=si>{</span><span class=n>object_id</span><span class=si>}</span><span class=s2> not found.&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tool_context</span><span class=o>.</span><span class=n>state</span><span class=p>[</span><span class=s2>&#34;current_state&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>state</span>
</span></span><span class=line><span class=cl>    <span class=n>logger</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Deleted object </span><span class=si>{</span><span class=n>object_id</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;success&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;message&#34;</span><span class=p>:</span> <span class=sa>f</span><span class=s2>&#34;Deleted object </span><span class=si>{</span><span class=n>object_id</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><ul><li><strong>User says:</strong> &ldquo;Remove the circle.&rdquo;</li><li><strong>LLM thinks:</strong> &ldquo;The user means the object with <code>type: circle</code>. I see one with <code>id: obj1</code>. I will call <code>tool_delete_object('obj1')</code>.&rdquo;</li></ul><p>The system provides the fundamental interface; the Agent maps the <strong>User Intent</strong> to that <strong>Interface</strong>. This is the key benefit: your backend defines <strong>what</strong> is possible, and the LLM figures out <strong>how</strong> to map messy human requests to those rigid definitions.</p><h2 id=how-tool-calling-works>How Tool Calling Works</h2><p>How does the LLM know which function to call? Agent frameworks (like the Google ADK) use Python&rsquo;s <strong>reflection</strong> (code inspecting itself) to create a &ldquo;user manual&rdquo; for the model. It&rsquo;s like how your IDE autocompletes your code.</p><ol><li><p><strong>Semantic Mapping (The &ldquo;Why&rdquo;):</strong>
The system reads your <strong>Docstrings</strong> (via <code>func.__doc__</code>) to understand intent. When I write <code>"""Delete an object from the state by its ID"""</code>, the LLM uses that description to understand <em>when</em> to use the tool. This is why you don&rsquo;t need to program synonyms—the model matches &ldquo;destroy&rdquo; to &ldquo;Delete&rdquo; semantically.</p></li><li><p><strong>Structural Mapping (The &ldquo;How&rdquo;):</strong>
The system inspects your <strong>Type Hints</strong> (like <code>str</code>, <code>int</code>, or Pydantic models). It converts <code>def tool_add_object(shape: Shape)</code> into a strict JSON Schema that the LLM must follow.</p><ul><li><strong>Python:</strong> <code>def tool_add_object(shape: Shape)</code></li><li><strong>LLM Context:</strong> <code>{"name": "tool_add_object", "parameters": {"shape": {"type": "object", "properties": {...}}}}</code></li></ul></li></ol><p>This ensures that the agent doesn&rsquo;t just &ldquo;guess&rdquo; parameters—it is constrained to generate valid JSON that matches your exact data structure.</p><p>For a detailed breakdown of tool calling mechanics, check out <a href=https://amitness.com/posts/function-calling-schema/>The Anatomy of Tool Calling</a>.</p><h2 id=the-system-prompt>The System Prompt</h2><p>If Tools are the <strong>Hands</strong> of the agent, the System Prompt is its <strong>Brain</strong>.</p><p>In the ADK, this isn&rsquo;t &ldquo;You are a helpful assistant.&rdquo; It is a rigorous set of operating procedures. The prompt handles validation logic that used to require complex code:</p><ol><li><strong>Identity & Role:</strong> &ldquo;You are a state-management assistant.&rdquo;</li><li><strong>Behavioral Guidelines:</strong> &ldquo;When adding objects, generate meaningful IDs (e.g., &lsquo;circle_1&rsquo;).&rdquo;</li><li><strong>Procedural Logic:</strong> &ldquo;If the user asks to &lsquo;move&rsquo; something, find it by ID first.&rdquo;</li></ol><p>This is the subtle power of the system: <strong>Logic is now text.</strong>
Instead of writing a regex to validate an ID, I simply tell the agent: <em>&ldquo;Make sure IDs are unique and descriptive.&rdquo;</em> The agent enforces this rule dynamically, correcting itself if it fails. It turns rigid logic into flexible, semantic instructions.</p><h2 id=natural-language-interfaces>Natural Language Interfaces</h2><p>In my opinion, this shift is paving the way for <strong>Natural Language User Interfaces (NUI)</strong>.</p><p>Traditionally, Product Managers had to predict every possible action a user might want and build a specific UI component for it. If you wanted to &ldquo;swap the positions of the square and the triangle,&rdquo; you needed a specific &ldquo;Swap&rdquo; button or a complex drag-and-drop implementation.</p><p>With an agentic flow, users can reference things by <strong>semantics</strong> (or &ldquo;vibes&rdquo;). You define the atomic actions (add, delete, move), and the Agent handles combinations the Product Manager never even thought of.</p><h2 id=wrapping-up>Wrapping Up</h2><p>By exposing our application state to LLMs via defined tools we are building flexible interfaces that adapt to how users actually think.</p></div><p style=font-size:1.65em;text-align:center><a href=/blogs/posts/20240521115848-refactoring_with_singleton/>&#8678;</a></p><hr><hr><footer><main><h3>Comments</h3><script src=https://utteranc.es/client.js repo=utsavdarlami/blogs issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></main></footer></article></main><footer></footer></body></html>